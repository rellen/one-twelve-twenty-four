# Erlang/OTP 24 and Elixir 1.12 Release Bonanza!

## Intro

May 2021 is an exciting time in the Erlang ecosystem!

* May 12 saw the release of Erlang/OTP 24
  * BeamAsm JIT compiler
  * better error messages
* Elixir 1.12 is imminent
  * scripting improvements
  * OTP24 integration
  * stepped ranged
  * additional functions in the standard library
* Livebook
* Axon

## Livebook

<img src="https://github.com/elixir-nx/livebook/raw/main/priv/static/logo-with-text.png" />

* Interactive code notebook for Elixir built on Phoenix LiveView, by the Elixir Nx team
* [https://github.com/elixir-nx/livebook](https://github.com/elixir-nx/livebook)

## OTP 24

```elixir
:erlang.system_info(:otp_release)
```

### BeamAsm Just-in-Time compiler

> BeamAsm provides load-time conversion of Erlang BEAM instructions into native code on x86-64. This allows the loader to eliminate any instruction dispatching overhead and also specialize each instruction on their argument types.

[https://erlang.org/doc/apps/erts/BeamAsm.html](https://erlang.org/doc/apps/erts/BeamAsm.html)

[https://blog.erlang.org/a-first-look-at-the-jit/](https://blog.erlang.org/a-first-look-at-the-jit/)

___

#### Built using `AsmJit`

* [https://asmjit.com/](https://asmjit.com/)
* C++ JIT machine code generator

___

#### JIT is enabled by default in OTP24

```elixir
:erlang.system_info(:emu_flavor)
```

### EEP54

> Extended error information for failing BIF calls as proposed in EEP 54

* foil our old nemesis, `ArgumentError`

```
iex(1)> :ets.insert(:foo, {:bar, :baz})
** (ArgumentError) argument error
   (stdlib 3.14.2) :ets.insert(:foo, {:bar, :baz})
iex(1)>
```

```elixir
:ets.insert(:foo, {:bar, :baz})
```

```elixir
ref = :ets.new(:foo, [])
:ets.insert(ref, :bar)
```

## Elixir 1.12

```elixir
System.version()
```

### `Mix.install`

call `Mix.install([deps])` in scripts to avoid requiring a Mix project

```elixir
# this is a hack to demonstrate how Mix.install works (as opposed to how to use in Livebook, scripts etc)
code = "IO.puts(Poison.encode!(%{hello: :world}))"
{stdout, _res} = System.cmd("elixir", ["--eval", code], stderr_to_stdout: true)
IO.puts(stdout)
```

```elixir
# this is a hack to demonstrate how Mix.install works (as opposed to how to use in Livebook, scripts etc)
# in your scripts and Livebooks, just call the contents of code directly
code = """
Mix.install([:poison], force: true)
IO.puts(Poison.encode!(%{hello: :world}))
"""

{stdout, _res} = System.cmd("elixir", ["--eval", code], stderr_to_stdout: false)
IO.puts(stdout)
```

### `System.trap_signal/2`

```elixir
parent = self()

System.trap_signal(:sigusr2, :id, fn ->
  Process.send(parent, {:msg, "Got SIGUSR2"}, [])
end)

:os.cmd(String.to_charlist("kill -s USR2 #{:os.getpid()}"))

receive do
  {:msg, msg} -> IO.puts(inspect(msg))
after
  2000 -> IO.puts("oops")
end

System.untrap_signal(:sigusr2, :id)
```

### `Kernel.then`

```elixir
defmodule ThenTest1 do
  defstruct [:field]
end

%{}
|> Map.put(:field, "value")
|> (fn map -> Kernel.struct(ThenTest1, map) end).()
```

```elixir
defmodule ThenTest2 do
  defstruct [:field]
end

%{}
|> Map.put(:field, "value")
|> then(&struct(ThenTest2, &1))
```

### `Kernal.tap`

```elixir
parent = self()
side_effect = fn x -> Process.send(parent, {:greeting, x}, []) end

"hello"
|> tap(side_effect)
|> String.reverse()
|> IO.puts()

receive do
  {:greeting, greeting} -> IO.puts("Got greeting: #{inspect(greeting)}")
after
  2000 -> IO.puts("Oops - no greeting")
end
```

## Axon
