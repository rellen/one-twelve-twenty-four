# Erlang/OTP 24 and Elixir 1.12 Release Bonanza!

## Intro

May 2021 is an exciting time in the Erlang ecosystem!

* May 12 saw the release of Erlang/OTP 24
  * BeamAsm JIT compiler
  * better error messages
* Elixir 1.12 is imminent
  * scripting improvements
  * OTP24 integration
  * stepped ranged
  * additional functions in the standard library
* Livebook
* Axon

## Livebook

<img src="https://github.com/elixir-nx/livebook/raw/main/priv/static/logo-with-text.png" />

* Interactive code notebook for Elixir built on Phoenix LiveView, by the Elixir Nx team
* [https://github.com/elixir-nx/livebook](https://github.com/elixir-nx/livebook)

## OTP 24

```elixir
:erlang.system_info(:otp_release)
```

### BeamAsm Just-in-Time compiler

> BeamAsm provides load-time conversion of Erlang BEAM instructions into native code on x86-64. This allows the loader to eliminate any instruction dispatching overhead and also specialize each instruction on their argument types.

[https://erlang.org/doc/apps/erts/BeamAsm.html](https://erlang.org/doc/apps/erts/BeamAsm.html)

[https://blog.erlang.org/a-first-look-at-the-jit/](https://blog.erlang.org/a-first-look-at-the-jit/)

___

#### Built using `AsmJit`

* [https://asmjit.com/](https://asmjit.com/)
* C++ JIT machine code generator

___

#### JIT is enabled by default in OTP24

```elixir
:erlang.system_info(:emu_flavor)
```

### EEP54

> Extended error information for failing BIF calls as proposed in EEP 54

* foil our old nemesis, `ArgumentError`

```
iex(1)> :ets.insert(:foo, {:bar, :baz})
** (ArgumentError) argument error
   (stdlib 3.14.2) :ets.insert(:foo, {:bar, :baz})
iex(1)>
```

```elixir
:ets.insert(:foo, {:bar, :baz})
```

```elixir
ref = :ets.new(:foo, [])
:ets.insert(ref, :bar)
```

## Elixir 1.12

```elixir
System.version()
```

### `Mix.install`

```elixir
{stdout, _res} =
  System.cmd(
    "elixir",
    ["--eval", "IO.puts(Poison.encode!(%{hello: :world}))"],
    stderr_to_stdout: true
  )

IO.puts(stdout)
```

```elixir
{stdout, _res} = System.cmd("elixir",
   ["--eval",
    "Mix.install([:poison], force: true);IO.puts(Poison.encode!(%{hello: :world}))"]
    ,stderr_to_stdout: true)
IO.puts(stdout)
```

### `System.trap_signal/2`

```elixir
parent = self()

System.trap_signal(:sigusr2, :id, fn ->
  Process.send(parent, {:msg, "Got SIGUSR2"}, [])
end)

:os.cmd(String.to_charlist("kill -s USR2 #{:os.getpid()}"))

receive do
  {:msg, msg} -> IO.puts(inspect(msg))
after
  2000 -> IO.puts("oops")
end

System.untrap_signal(:sigusr2, :id)
```

### `Kernel.then`

```elixir
defmodule ThenTest1 do
  defstruct [:field]
end

%{}
|> Map.put(:field, "value")
|> (fn map -> Kernel.struct(ThenTest1, map) end).()
```

```elixir
defmodule ThenTest2 do
  defstruct [:field]
end

%{}
|> Map.put(:field, "value")
|> then(&struct(ThenTest2, &1))
```

### `Kernal.tap`

```elixir
parent = self()
side_effect = fn x -> Process.send(parent, {:greeting, x}, []) end

"hello"
|> tap(side_effect)
|> String.reverse()
|> IO.puts()

receive do
  {:greeting, greeting} -> IO.puts("Got greeting: #{inspect(greeting)}")
after
  2000 -> IO.puts("Oops - no greeting")
end
```

## Axon
